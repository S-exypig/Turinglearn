### 项目流程

### 软件生命周期

1. 可行性分析+软件开发计划
2. 需求分析
3. 概要设计
4. 详细设计
5. 编码
6. 测试
7. 上线维护



### 基本流程

1. 立项+可行 性分析+项目计划
2. 产品需求：需求文档，功能流程图，产品原型图
3. 架构
4. 分工开发
5. 整合 测试
6. 答辩



### 可行性分析

1. 考虑用哪些技术
2. 考虑核心功能
3. 考虑是否能做
   1. 数据描述 代码
   2. 逻辑描述 文字



### 俄罗斯方块可行性分析

#### 技术

1. 读取键盘行为 左右控制方向，上控制旋转，下控制速度



#### 核心功能

1. 界面：展示游戏界面和方块
2. 生成方块
3. 方块的形状
4. 方块下落和左右移动
5. 方块的左右旋转
6. 方块停止：碰撞检测
7. 方块消除
8. 延迟和计时器：控制下落速度
9. 游戏结束：边缘检测
10. 分数

#### 扩展功能

1. 下落加速
2. 更换皮肤和背景
3. 排行榜
4. 游戏暂停和存档
5. 难度：增快下落速度
6. 背景音乐、消除音效
7. 胜利界面，破纪录界面
8. 道具，例如可消除最上面几行，炸弹消除一块区域类似开心消消乐

#### 是否能做

1. 界面使用二维数组：

   `	vector<vector<uint32_t>> area(L,vector<uint32_t>(C);`

   L行C列的平面area作为游戏的空间，area[ i ] [ j ]为0则为空地，1则为方块

2. 方块的形状用二位数组表示：

   `std::vector<std::vector<std::uint32_t>> forms`

   如{2，4，5，7}：0 1

   ​								==2== 3

   ​								==4== ==5==

   ​								6 ==7==

3. 方块的位置用结构体表示

   ```cpp
   struct Coords{
   	std::uint32_t x, y; // x，y代表该方块的坐标
   }z[squares];
   ```

4. 旋转，还未想出

5. 方块下落：遍历每一方块，判断z[ squares ].x+1和z[ squares ].y+1是否碰撞到边缘，是否是1，若都不越界且都不为1，则+1

      ```cpp
      maxLimit() { // 边界检测
      	for (std::size_t i {}; i < squares; ++i) {
      		if (z[i].x < 0 ||
      			z[i].x >= cols ||
      			z[i].y >= lines ||
      			area[z[i].y][z[i].x]) {
      			return true;
      		}
      	}
      	return false;
      ```


6. 方块消除：从底向上逐行，从左到右遍历整张area，若存在某行全为1，则消除该行（全赋值为0）。每消除一行，将上面的每行逐行下落。

   ```cpp
   clear(){
   	for(std::size_t i{lines};i>=0;--i){
   		bool flag=true;
   		for(std::size_t j{0};j<cols;++j){
   			if(area[i][j]==0){
   				flag=false;
   				break;
   			}
   		}
           if(flag){
           	//从该行往上遍历每一行，整体下移一格
           	flag=false;
           }
   	}
   }
   ```


7. 计时器和延迟：用float存储，当计时器超过阈值时，方块下落，计时器清零。
8. 游戏结束：每次生成方块时，判断area最上面一行是否有1（并未考虑周全，仅有简单思路）
9. 分数：用一个整型如int，std::uint32_t等存储，当方块消除时加分。
